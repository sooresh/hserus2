<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hserus2</title>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent: #4caf50; /* Green */
            --accent-hover: #45a049;
            --border: #333;
            --table-header: #2c2c2c;
            --red: #ff5252;
            --green: #4caf50;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 800px;
        }

        /* Controls Area */
        .controls {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.5rem; }

        button {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        button:hover { background-color: var(--accent-hover); }
        button:disabled { background-color: #555; cursor: not-allowed; }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            background-color: #333;
            border-radius: 4px;
            height: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--accent);
            transition: width 0.3s ease-out;
        }

        .status-text {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: right;
            margin-top: -10px;
        }

        /* Table */
        .table-wrapper {
            background-color: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            text-align: left;
        }

        th, td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border);
        }

        th {
            background-color: var(--table-header);
            color: var(--text-muted);
            font-size: 0.85rem;
            text-transform: uppercase;
            cursor: pointer;
            user-select: none;
        }

        th:hover { color: var(--text-main); }

        /* Sort Icons */
        th span { margin-left: 5px; font-size: 0.7rem; }

        td { font-size: 0.95rem; }
        
        tr:last-child td { border-bottom: none; }
        tr:hover { background-color: #2a2a2a; }

        .positive { color: var(--green); }
        .negative { color: var(--red); }

        .hidden { display: none; }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <div class="header-row">
            <h1>hserus2</h1>
            <button id="scanBtn" onclick="startScan()">Start Scan</button>
        </div>
        
        <div class="progress-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>
        <div id="statusText" class="status-text">Ready</div>
    </div>

    <div class="table-wrapper">
        <table id="resultTable">
            <thead>
                <tr>
                    <th onclick="sortTable('symbol')">Symbol <span id="sort-symbol"></span></th>
                    <th onclick="sortTable('price')">Price % <span id="sort-price"></span></th>
                    <th onclick="sortTable('vol')">Vol % <span id="sort-vol"></span></th>
                </tr>
            </thead>
            <tbody id="tableBody">
                </tbody>
        </table>
    </div>
</div>

<script>
    // --- Configuration ---
    const BASE_URL = 'https://fapi.binance.com';
    const EXCLUDED_COINS = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'USDCUSDT', 'DOGEUSDT', 'TRXUSDT', 'AVAXUSDT', 'LINKUSDT', 'DOTUSDT', 'MATICUSDT'];
    const BATCH_SIZE = 5; // Parallel requests
    
    // --- State ---
    let scanResults = [];
    let sortConfig = { key: 'vol', dir: 'desc' }; // Default sort: Volume Desc
    let isScanning = false;

    // --- DOM Elements ---
    const btn = document.getElementById('scanBtn');
    const pBar = document.getElementById('progressBar');
    const sText = document.getElementById('statusText');
    const tBody = document.getElementById('tableBody');

    // --- Helpers ---
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // --- Core Logic ---

    async function startScan() {
        if (isScanning) return;
        isScanning = true;
        btn.disabled = true;
        btn.innerText = "Scanning...";
        scanResults = [];
        updateTable();
        pBar.style.width = '0%';
        sText.innerText = "Fetching market pairs...";

        try {
            // 1. Fetch 24hr Ticker to get top volatile pairs
            const tickerRes = await fetch(`${BASE_URL}/fapi/v1/ticker/24hr`);
            const tickers = await tickerRes.json();

            // 2. Filter & Sort by Volatility (High-Low range %)
            // We use (High - Low) / Low as a proxy for volatility
            let validPairs = tickers.filter(t => 
                t.symbol.endsWith('USDT') && 
                !EXCLUDED_COINS.includes(t.symbol)
            ).map(t => ({
                symbol: t.symbol,
                volatility: (parseFloat(t.highPrice) - parseFloat(t.lowPrice)) / parseFloat(t.lowPrice)
            }));

            // Sort by volatility desc, take top 250
            validPairs.sort((a, b) => b.volatility - a.volatility);
            const targets = validPairs.slice(0, 250).map(t => t.symbol);

            // 3. Process in batches
            sText.innerText = `Scanning ${targets.length} symbols...`;
            let completed = 0;

            for (let i = 0; i < targets.length; i += BATCH_SIZE) {
                const batch = targets.slice(i, i + BATCH_SIZE);
                
                // Fetch batch in parallel
                const promises = batch.map(symbol => checkSymbol(symbol));
                const results = await Promise.all(promises);

                // Filter out nulls (non-matches) and add to list
                results.forEach(res => {
                    if (res) scanResults.push(res);
                });

                // Update Progress
                completed += batch.length;
                const progress = Math.min((completed / targets.length) * 100, 100);
                pBar.style.width = `${progress}%`;
                sText.innerText = `${completed} / ${targets.length}`;

                // Render intermediate results every few batches to feel "fast"
                if (i % 20 === 0) updateTable();
                
                // Tiny delay to prevent browser freeze & be nice to API
                await sleep(50); 
            }

            sText.innerText = `Done. Found ${scanResults.length} matches.`;

        } catch (error) {
            console.error(error);
            sText.innerText = "Error: Check Console (CORS or Network)";
        } finally {
            isScanning = false;
            btn.disabled = false;
            btn.innerText = "Refresh";
            updateTable(); // Final Sort & Render
        }
    }

    async function checkSymbol(symbol) {
        try {
            // Fetch 3 recent candles: 1h interval
            // Limit 4 to be safe, we need [prevPrev, prev, curr]
            const url = `${BASE_URL}/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=5`;
            const res = await fetch(url);
            const data = await res.json();

            if (!data || data.length < 3) return null;

            // Data format: [time, open, high, low, close, volume, ...]
            // Array is chronological. Last one is Current.
            const curr = parseCandle(data[data.length - 1]);
            const prev = parseCandle(data[data.length - 2]);
            const pprev = parseCandle(data[data.length - 3]);

            // --- Conditions ---

            // 1. Current Vol > Prev Vol * 1.5
            if (curr.vol <= prev.vol * 1.5) return null;

            // 2. Prev Vol > Prev Prev Vol
            if (prev.vol <= pprev.vol) return null;

            // 3. Color Logic
            // Color same for Curr & Prev, Different for PPrev
            // Green = Close > Open, Red = Close < Open
            const isGreen = (c) => c.close > c.open;
            
            const currColor = isGreen(curr);
            const prevColor = isGreen(prev);
            const pprevColor = isGreen(pprev);

            // Curr & Prev must match
            if (currColor !== prevColor) return null;
            // PPrev must be different
            if (pprevColor === prevColor) return null;

            // 4. Total Length Logic (High - Low)
            const currLen = curr.high - curr.low;
            const prevLen = prev.high - prev.low;
            
            if (currLen <= prevLen) return null;

            // --- Calculation for Display ---
            // Price % Change (Current Close vs Current Open)
            const priceChgRaw = ((curr.close - curr.open) / curr.open) * 100;
            
            // Vol % Increase (Current vs Prev)
            // (Current / Prev) * 100 to show magnitude, or simple % chg
            const volChgRaw = ((curr.vol - prev.vol) / prev.vol) * 100;

            return {
                symbol: symbol,
                price: priceChgRaw,
                vol: volChgRaw
            };

        } catch (e) {
            return null; // Fail silently for individual symbol errors
        }
    }

    function parseCandle(c) {
        return {
            open: parseFloat(c[1]),
            high: parseFloat(c[2]),
            low: parseFloat(c[3]),
            close: parseFloat(c[4]),
            vol: parseFloat(c[5])
        };
    }

    // --- UI & Sorting ---

    function sortTable(key) {
        // Toggle direction if clicking same header
        if (sortConfig.key === key) {
            sortConfig.dir = sortConfig.dir === 'asc' ? 'desc' : 'asc';
        } else {
            sortConfig.key = key;
            sortConfig.dir = 'desc'; // Default to desc for new columns
        }
        updateSortIcons();
        updateTable();
    }

    function updateSortIcons() {
        ['symbol', 'price', 'vol'].forEach(k => {
            const span = document.getElementById(`sort-${k}`);
            span.innerHTML = '';
            if (sortConfig.key === k) {
                span.innerHTML = sortConfig.dir === 'asc' ? '▲' : '▼';
            }
        });
    }

    function updateTable() {
        tBody.innerHTML = '';

        // Sort Data
        scanResults.sort((a, b) => {
            let valA = a[sortConfig.key];
            let valB = b[sortConfig.key];
            
            // String sort for symbol, number for others
            if (sortConfig.key === 'symbol') {
                return sortConfig.dir === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
            } else {
                return sortConfig.dir === 'asc' ? valA - valB : valB - valA;
            }
        });

        // Render
        if (scanResults.length === 0) {
            const tr = document.createElement('tr');
            tr.innerHTML = '<td colspan="3" style="text-align:center; padding: 20px;">No matches found yet</td>';
            tBody.appendChild(tr);
            return;
        }

        scanResults.forEach(item => {
            const tr = document.createElement('tr');
            
            // Format Price %
            const pClass = item.price >= 0 ? 'positive' : 'negative';
            const pSign = item.price >= 0 ? '+' : '';
            const pText = `${pSign}${item.price.toFixed(2)}%`;

            // Format Vol %
            const vText = `+${item.vol.toFixed(2)}%`;

            tr.innerHTML = `
                <td style="font-weight:bold; color: #fff;">${item.symbol}</td>
                <td class="${pClass}">${pText}</td>
                <td style="color: #4caf50;">${vText}</td>
            `;
            tBody.appendChild(tr);
        });
    }

    // Initialize Sort Icons
    updateSortIcons();

</script>

</body>
</html>
