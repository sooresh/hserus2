<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>hserus2</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#0b0b0b;color:#eee;text-align:center}
  h2{color:#00e676}
  button{background:#00e676;color:#000;border:none;padding:10px 20px;margin:10px;border-radius:5px;cursor:pointer;font-weight:bold}
  button:hover{background:#00c853}
  #progressContainer{width:90%;background:#222;border-radius:8px;margin:10px auto;height:18px;overflow:hidden}
  #progressBar{height:100%;width:0;background:#00e676;transition:width .3s}
  #progressText{margin:6px;color:#ffeb3b}
  table{width:95%;margin:20px auto;border-collapse:collapse;background:#121212}
  th,td{padding:10px;border:1px solid #333}
  th{background:#1c1c1c;cursor:pointer}
  tr:nth-child(even){background:#181818}
</style>
</head>
<body>

<h2>hserus2</h2>
<button onclick="fetchScanner()">ðŸ”„ Refresh</button>
<div id="progressContainer"><div id="progressBar"></div></div>
<div id="progressText"></div>

<table id="resultTable">
  <thead>
    <tr>
      <th onclick="sortTable(0)">Symbol</th>
      <th onclick="sortTable(1)">Max Chg%</th>
      <th onclick="sortTable(2)">Vol%</th>
      <th onclick="sortTable(3)">Prev Vol%</th>
      <th onclick="sortTable(4)">Prev/Cur Body%</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
let sortDir=[true,true,true,true,true];

async function fetchScanner(){
  const progressBar=document.getElementById("progressBar");
  const progressText=document.getElementById("progressText");
  const tbody=document.querySelector("#resultTable tbody");
  tbody.innerHTML=""; progressBar.style.width="0%"; progressText.textContent="Loading symbols...";

  try{
    // Step 1 â€“ Fetch Binance symbols
    const exInfo=await fetch("https://fapi.binance.com/fapi/v1/exchangeInfo").then(r=>r.json());
    let symbols=exInfo.symbols.filter(s=>s.symbol.endsWith("USDT")&&s.contractType==="PERPETUAL")
      .map(s=>s.symbol)
      .filter(s=>!["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","DOGEUSDT","ADAUSDT","AVAXUSDT",
                   "DOTUSDT","LINKUSDT","TRXUSDT","MATICUSDT","TONUSDT","LTCUSDT","BCHUSDT","SHIBUSDT",
                   "UNIUSDT","ETCUSDT","ICPUSDT","APTUSDT"].includes(s))
      .slice(0,250);

    const total=symbols.length; let done=0; let results=[];
    const batchSize=20;

    async function processSymbol(sym){
      try{
        const data=await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1h&limit=4`).then(r=>r.json());
        if(!Array.isArray(data)||data.length<4)return;
        const prevPrev=data[data.length-3], prev=data[data.length-2], curr=data[data.length-1];

        const [o0, h0, l0, c0, v0] = [parseFloat(prevPrev[1]), parseFloat(prevPrev[2]), parseFloat(prevPrev[3]), parseFloat(prevPrev[4]), parseFloat(prevPrev[5])];
        const [o1, h1, l1, c1, v1] = [parseFloat(prev[1]), parseFloat(prev[2]), parseFloat(prev[3]), parseFloat(prev[4]), parseFloat(prev[5])];
        const [o2, h2, l2, c2, v2] = [parseFloat(curr[1]), parseFloat(curr[2]), parseFloat(curr[3]), parseFloat(curr[4]), parseFloat(curr[5])];

        // --- Conditions ---
        if(v2 <= v1 * 1.6) return; // cond 1: volume
        const currGreen = c2 > o2, prevGreen = c1 > o1;
        if(currGreen === prevGreen) return; // cond 2: opposite colors
        const bodyCur = Math.abs(c2 - o2);
        const bodyPrev = Math.abs(c1 - o1);
        if(bodyPrev < bodyCur * 0.2) return; // cond 3: prev body <20%

        // --- Metrics ---
        const closePctCur = ((c2 - o2) / o2) * 100;
        const closePctPrev = ((c1 - o1) / o1) * 100;
        const maxChg = Math.max(Math.abs(closePctCur), Math.abs(closePctPrev)).toFixed(2);
        const volPct = ((v2 / v1) - 1) * 100;
        const prevVolPct = ((v1 / v0) - 1) * 100;
        const bodyRatio = (bodyPrev / bodyCur) * 100;

        results.push({symbol:sym,maxChg,volPct:volPct.toFixed(2),prevVolPct:prevVolPct.toFixed(2),bodyRatio:bodyRatio.toFixed(2)});
      }catch(e){/*ignore*/}finally{
        done++; progressBar.style.width=((done/total)*100).toFixed(1)+"%";
        progressText.textContent=`Scanning ${done}/${total} symbols...`;
      }
    }

    // Step 2 â€“ Parallel batches
    for(let i=0;i<symbols.length;i+=batchSize){
      await Promise.all(symbols.slice(i,i+batchSize).map(processSymbol));
    }

    // Step 3 â€“ Display
    tbody.innerHTML=results.map(r=>`
      <tr>
        <td>${r.symbol}</td>
        <td>${r.maxChg}%</td>
        <td>${r.volPct}%</td>
        <td>${r.prevVolPct}%</td>
        <td>${r.bodyRatio}%</td>
      </tr>`).join("");
    progressBar.style.width="100%";
    progressText.textContent=`âœ… Completed. ${results.length} matches.`;
  }catch(err){
    progressText.textContent="âŒ Error loading data.";
    console.error(err);
  }
}

function sortTable(n){
  const table=document.getElementById("resultTable");
  const tbody=table.tBodies[0];
  const rows=Array.from(tbody.rows);
  const asc=sortDir[n];
  rows.sort((a,b)=>{
    let x=a.cells[n].innerText.replace('%','');
    let y=b.cells[n].innerText.replace('%','');
    let nx=parseFloat(x)||x.toLowerCase(), ny=parseFloat(y)||y.toLowerCase();
    return asc?(nx>ny?1:-1):(nx<ny?1:-1);
  });
  rows.forEach(r=>tbody.appendChild(r));
  sortDir[n]=!asc;
}

fetchScanner();
</script>
</body>
</html>
